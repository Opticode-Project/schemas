namespace program;

// WARN - START OF REFACTOR SECTOR
// This portion of types must be refactored to accommodate all supported languages
// Currently this only represents the Go types model

union Type {
  PointerType,
  StructureType,
  FunctionType,
  MapType,
  ArrayType,
  TupleType
}

table Pair {
  key: uint;
  value: uint;
}

table StructureField {
  name: uint;                // String Pointer
  type: uint;                // Type Definition
  misc: uint;                // String Pointer
}

table PointerType {
  elem: uint;                // Type Definition
}

table TupleType {
  elem: [uint];              // Type Definition
}

// This will work in the following language models with proper flags, int spliting, and taking advantage of integers as a pointer to a string:
// TS (interface/class)
// Go (struct/interface)
// C (struct)
// C++ (struct/class)
// C# (dict)
// Lua (dict)
// Pascal (record)
// PHP (class)
// Dart (class)
// GLSL (struct)
// Haskell (data)
// Kotlin (class)
// MATLAB (struct)
// MOJO (struct)
// SQL (table)
// Zig (struct)
// Python (class)
// Rust (struct)
table StructureType {
  fields: [StructureField];
  defs: [uint];          // Array of Type Definitions
}

// This will work in the following language models with proper flags, int spliting, and taking advantage of integers as a pointer to a string:
// Go
// TS
// C (Heavy on flags)
// C++ (Heavy on flags)
// C# (Heavy on flags)
// Lua
// Pascal
// PHP
// Dart
// GLSL
// Haskell
// Kotlin
// MATLAB
// MOJO
// SQL
// Zig
// Python
// Rust
table FunctionType {
  params: [Pair];
  results: [Pair];
  impl: Pair;
  type_sig: uint;
}

// This will work in the following language models with proper flags, int spliting, and taking advantage of integers as a pointer to a string
// Go
// TS
// C (No native map type)
// C++ (Standard library)
// C# (Dictionary)
// Lua
// Pascal
// PHP
// Dart
// GLSL
// Haskell
// Kotlin
// MATLAB
// MOJO (Dict)
// SQL
// Zig
// Python
// Rust
table MapType {
  key: uint;            // Type Definition
  value: uint;          // Type Definition
}

// This will work in the following language models with proper flags, int spliting, and taking advantage of integers as a pointer to a string
// Go
// TS (Heavy on flags)
// C (Heavy on flags)
// C++ (Heavy on flags)
// C# (Heavy on flags)
// Lua (maybe)
// Pascal (maybe not indexed arrays)
// PHP (maybe)
// Dart
// GLSL
// Haskell (needs pointers for desugars to a linked list)
// Kotlin
// MATLAB (maybe)
// SQL
// Zig
// Python
// Rust
table ArrayType {
  elem: uint;           // Type Definition
  size: ulong;          // For multi dimensional arrays, integer is split
}

table TypeDef {
  base: uint;           // Kind enum or pointer address of type
  id: uint;
  type: Type;
  flags: uint;
}

enum ProgramFlag: uint {
    // When a program buffer reaches it maximum size, it gets split into segments.
    // Each bit flag represents the order of the current buffer.
    // Therefore, there can be only be up to four segments.
    FirstSegment = 0,
    SecondSegment = 1,
    ThirdSegment = 2,
    ForthSegment = 4,
}

// --- Flags ---
enum Flag: uint {
  None = 0,             // NOTE - Reserved
  NodeIndexed = 1,      // NOTE - Reserved
  NodeBinary = 2,       // NOTE - Reserved
  NodeUnary = 4,        // NOTE - Reserved
}

enum ValueFlag: uint {
  None = 0,             // NOTE - Reserved
  Pointer = 1,          // NOTE - Reserved
}

// --- Nodes ---
table NodeValue {
  type: uint;
  value: long;         // Look up for value
  flags: uint;
}

union NodeUnion {
  IndexedNode,        // If node contains array or requires id
  BinaryNode,         // If node only requires 2 node values and no id
  UnaryNode,          // If node only required 1 node value and no id
}

table IndexedNode {
  id: uint;
  fields: [NodeValue];
}

table BinaryNode {
  left:NodeValue;
  right:NodeValue;
}

table UnaryNode {
  value:NodeValue;     // Any flags stored outside of the node content
}

table Node {
  id: long;             // unique node id
  opcode: uint;         // opcode of node
  parent: long;         // parent node id
  next: long;           // next sibling id
  flags: uint;          // contains the node type and miscellanous flags
  node: NodeUnion;      // actual node contents
}

table StringEntry {
  key: uint(key);
  value: string;
}

table TypeEntry {
  key: uint(key);
  value: TypeDef;
}

table App {
  nodes: [Node];           // Flat array of all nodes
  lut: [StringEntry];      // String lookup table
  types: [TypeEntry];      // Type registry
  name: string;
  schver: string;          // Schema version
  wailsver: string;        // Version of wails
  version: string;         // Version of the program
  flags: ProgramFlag;      // Program flags
}

root_type App;

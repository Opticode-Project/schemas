namespace golang;

// Represents all compiler opcodes generated from node types in Opticode
enum Opcode : uint {
  // --- Declarations ---
  Package = 0,        // package <identifier> | Type1
  Import = 1,         // import "<path>" | Type1
  ImportValue,        // <name> "<url>"   | Type2
  Const,              // const <name> = <expr> | Type1
  ConstValue,         // <name> = <expr> | Type2
  Var,                // var <name> = <expr> | Type1
  VarValue,           // <name> = <expr> | Type2
  Type,               // type <name> <type> | Type1
  Func,               // func <name>(...) { ... } | Type1

  // --- Control Flow ---
  If,                 // if <cond> { ... } | Type1
  For,                // for <forRange> { ... } | Type1
  ForRange,           // <init>; <cond>; <post> | Type1
  Range,              // for <key>, <val> := range <expr> | Type1
  Switch,             // switch <expr> { ... } | Type1
  Select,             // select { ... } | Type1
  Case,               // case <expr>: <...> | Type1
  Default,            // default: <...> | Type1

  // --- Operators ---
  Add,                // <a> + <b> | Type2
  Sub,                // <a> - <b> | Type2
  Mul,                // <a> * <b> | Type2
  Div,                // <a> / <b> | Type2
  Mod,                // <a> % <b> | Type2
  Inc,                // <a>++ | Type3
  Dec,                // <a>-- | Type3
  Assign,             // <a> = <b> | Type2
  AddAssign,          // <a> += <b> | Type2
  SubAssign,          // <a> -= <b> | Type2
  MulAssign,          // <a> *= <b> | Type2
  DivAssign,          // <a> += <b> | Type2
  ModAssign,          // <a> %= <b> | Type2
  BitAndAssign,       // <a> &= <b> | Type2
  BitOrAssign,        // <a> |= <b> | Type2
  BitXorAssign,       // <a> ^= <b> | Type2
  BitClearAssign,     // <a> &^= <b> | Type2
  LeftShiftAssign,    // <a> <<= <b> | Type2
  RightShiftAssign,   // <a> >>= <b> | Type2
  Equal,              // <a> == <b> | Type2
  NotEqual,           // <a> != <b> | Type2
  Less,               // <a> < <b> | Type2
  LessEqual,          // <a> <= <b> | Type2
  Greater,            // <a> > <b> | Type2
  GreaterEqual,       // <a> >= <b> | Type2
  And,                // <a> && <b> | Type2
  Or,                 // <a> || <b> | Type2
  Not,                // !<a> | Type3
  BitAnd,             // <a> & <b> | Type2
  BitOr,              // <a> | <b> | Type2
  BitXor,             // <a> ^ <b> | Type2
  BitClear,           // <a> ^& <b> | Type2
  LeftShift,          // <a> << <b> | Type2
  RightShift,         // <a> >> <b> | Type2

  // --- Channels ---
  Send,               // ch <- val | Type2
  Receive,            // <-ch | Type3

  // --- Pointers & References ---
  AddrOf,             // &var | Type3
  Deref,              // *ptr | Type3

  // --- Functions & Calls ---
  Call,               // func(...) | Type1
  Return,             // return <expr> | Type3
  Defer,              // defer <call> | Type3
  GoRoutine,          // go <call> | Type3

  // --- Composite Types ---
  Map,                // map[keyType]valType{...} | Type1
  Array,              // [n]type{...} | Type1
  Chan,               // chan type | Type3

  // --- Error Handling ---
  Panic,              // panic(<expr>) | Type3
  Recover,            // recover() | NONE

  // --- Built-in & Special ---
  Make,               // make(...) | Type1
  New,                // new(type) | Type3
  Len,                // len(...) | Type1
  Cap,                // cap(...) | Type1
  Append,             // append(...) | Type1
  Copy,               // copy(dst, src) | Type2
  Close,              // close(ch) | Type3
  Complex,            // complex(...) | Type1
  Real,               // real(...) | Type1
  Imag,               // imag(...) | Type1
  Print,              // print(...) | Type1
  Println             // println(...) | Type1
}

// --- Types ---
enum Kind : uint {
  Nil = 0,          // AliasType
  Int = 1,          // AliasType
  Int8,             // AliasType
  Int16,            // AliasType
  Int32,            // AliasType
  Int64,            // AliasType
  Uint,             // AliasType
  Uint8,            // AliasType
  Uint16,           // AliasType
  Uint32,           // AliasType
  Uint64,           // AliasType
  Uintptr,          // AliasType
  Float32,          // AliasType
  Float64,          // AliasType
  Complex64,        // AliasType
  Complex128,       // AliasType

  String,           // AliasType
  Rune,             // AliasType
  Byte,             // AliasType

  Boolean,          // AliasType

  Pointer,          // PointerType
  Struct,           // StructType
  Func,             // FuncType
  Array,            // ArrayType
  Slice,            // ArrayType
  Map,              // MapType
  Channel,          // ChanType
  Interface         // InterfaceType
}

enum ChanDir : ubyte {
  Bidirectional = 0,
  Send = 1,
  Receive = 2,
}

union Type {
  PointerType,
  InterfaceType,
  StructType,
  FuncType,
  MapType,
  ArrayType,
  ChanType
}

table Pair {
  key: uint;
  value: uint;
}

table StructField {
  name: string;
  type: uint;
  tag: string;
}

table InterfaceMethod {
  name: string;
  func: Type;
}

table PointerType {
  elem: Type;
}

table InterfaceType {
  methods: [InterfaceMethod];
}

table StructType {
  fields: [StructField];
}

table FuncType {
  params: [Pair];
  results: [Pair];
  method: Pair;
}

table MapType {
  key: TypeDef;
  value: TypeDef;
}

table ChanType {
  elem: TypeDef;
  dir: ChanDir;
}

table ArrayType {
  elem: TypeDef;
  size: ulong;            // For multi dimensional arrays, integer is split 
}

table TypeDef {
  base: uint;             // Kind enum or pointer to type
  id: string;
  type: Type;
}


// --- Flags --- 
enum Flag : uint {
  None = 0,
  NodeIndexed = 1,
  NodeBinary = 2,
  NodeUnary = 4,
}

enum ValueFlag : uint {
  None = 0,
  Pointer = 1,
}

// --- Nodes ---
table NodeValue {
  type:uint;
  value:long;         // look up table for value
  flags:ValueFlag;
}

union NodeUnion {
  IndexedNode,        // If node contains array or requires id
  BinaryNode,         // If node only requires 2 node values and no id
  UnaryNode,          // If node only required 1 node value and no id
}

table IndexedNode {
  id:uint; // Should be an int to go into a reference table
  fields:[NodeValue];
}

table BinaryNode {
  left:NodeValue;
  right:NodeValue;
}

table UnaryNode {
  value:NodeValue; // Any flags stored outside of the node content
}

table Node {
  id:long;             // unique node id
  opcode:Opcode;       // opcode of node
  parent:long;         // parent node id
  next:long;           // next sibling id
  flags:Flag;          // contains the node type and miscellanous flags     
  node:NodeUnion;      // actual node contents
}

// Used for lookup table
table StringEntry {
  key:uint(key);
  value:string;
}

table TypeEntry {
  key:uint(key);
  value:TypeDef;
}

table Program {
  nodes:[Node];           // flat array of all nodes
  lut:[StringEntry];      // String lookup table
  types:[TypeEntry];      // Type registry
  name:string;
  schver:string;          // Schema version
  wailsver:string;        // Version of wails
  version:string;         // Version of the program
  flags:uint;             // I don't know what I would use this for yet
}

root_type Program;
